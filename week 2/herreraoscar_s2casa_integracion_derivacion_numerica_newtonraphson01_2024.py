# -*- coding: utf-8 -*-
"""HerreraOscar_S2CASA_Integracion_derivacion_numerica_NewtonRaphson01_2024.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13RopDdWFaVl8CLTq1e2CPIoqM8OBd9sB

EJERCICIO 1: NTEGRACIÓN NUMÉRICA
"""

#Este ejercicio preparatorio busca que usted implemente correctamente tres métodos de integración numérica. Pruebe distintos valores de h. Si termina el ejercicio antes de que acabe la clase, repita el proceso para el método de Monte Carlo y el método del valor medio.
import numpy as np
import matplotlib.pylab as plt
import scipy as sc

# Función a integrar
def funcion(x1):
    	return np.cos(x1)

#El intervalo de integración es de 0 a 3pi/2.
#Divida el intervalo de integración en M secciones para calcular sus integrales.
#pruebe distintos valores de M

# paso 1: use linespace (ver documentación: https://numpy.org/doc/stable/reference/generated/numpy.linspace.html)
# para hacer el arreglo de su intervalo en x
M=9999
a=0
b=3*np.pi/2
x=np.linspace(a,b,M)
#paso 2: genere el arreglo de valores de su función fx:
fx=funcion(x)

#1) grafique su función para verificar que hizo bien los pasos anteriores

import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
plt.plot(x,fx)

# 2a). Usando el método de suma de rectángulos, calcule la integral de la función.
#Compare su valor obtenido numéricamente con el valor analitico e imprima ambos valores.
h=(b-a)/(M-1)
Integral1=h*fx[1:].sum()
ErrorIntegrel1=-1-Integral1
print("Método de rectángulos=",Integral1)
print("Error del metodo del rectángulos:",ErrorIntegrel1)

# 2b). Usando el método de trapezoide, calcule la integral de la función.
#Compare su valor obtenido numéricamente con el valor analitico e imprima ambos valores.
htrap=h*np.ones(len(x))
htrap[0]=h/2
htrap[-1]=h/2
IntegralTrapezoide=(fx*htrap).sum()
ErrorTrapesoide=-1-IntegralTrapezoide
print("Método de trapezoide=",IntegralTrapezoide)
print("Error del metodo del trapezoide:",ErrorTrapesoide)

# 2c). Usando el método de Simpson, calcule la integral de la función.
#Compare su valor obtenido numéricamente con el valor analitico e imprima ambos valores.
simp_M=M+1-M%2
simp_h=(b-a)/(simp_M-1)
simp_x=np.linspace(a,b,simp_M)
hsimp=2*simp_h/3*np.ones(simp_M)
hsimp[1::2]=4*simp_h/3
hsimp[0]=simp_h/3
hsimp[-1]=simp_h/3
Inte_simp=(funcion(simp_x)*hsimp).sum()
Error_simp=-1-Inte_simp
print("Método de Simpson=",Inte_simp)
print("Error del metodo del Simpson:",Error_simp)

# 3)BONO: Implemente los métodos de Monte Carlo y de valor medio para calcular la integral
#-----------------------------------------------Monte Carlo---------------------------------------------------
#Se agregó una sección para permitir la visualización de los puntos en un gráfico, la cual quedará comentada
N_MC=int(1e5)
# FMC=[]
# XMC=[]
# YBOX=[]
# XBOX=[]
ran_x=np.random.random(N_MC)*(b-a)
ran_y=np.random.random(N_MC)*2-1
fx_MC=funcion(ran_x)
Npond=0
Nbox=0
for i in range(N_MC):
    if (ran_y[i]< fx_MC[i] and ran_y[i]>0) :
        Npond+=1
        # XMC.append(ran_x[i])
        # FMC.append(ran_y[i])
    elif (ran_y[i]> fx_MC[i] and ran_y[i]<0) :
        Npond-=1
        # XMC.append(ran_x[i])
        # FMC.append(ran_y[i])
    else:
        Nbox+=1
        # XBOX.append(ran_x[i])
        # YBOX.append(ran_y[i])

inte_MC=Npond/(N_MC)*(2*(b-a))

Error_inte_MC=-1-inte_MC

print("Método de Monte Carlo=",inte_MC)
print("Error del metodo del Monte Carlo:",Error_inte_MC)
# plt.plot(XMC,FMC,'bo',XBOX,YBOX,'ro',x,fx,markersize=1)
# plt.show()

#------------------------------------------------Valor Intermedio----------------------------------
N_VM=int(1e5)
X_VM=np.random.random(N_VM)*(b-a)
f_VM=funcion(X_VM)
V_prom=f_VM.mean()
inte_VM=V_prom*(b-a)
Error_VM=-1-inte_VM
print("Método de Valor Intermedio=",inte_VM)
print("Error del metodo del Valor Intermedio:",Error_VM)

# 4)BONO: Repita el ejercicio anterior usando algunos de los métodos de las librerías de scipy
# https://docs.scipy.org/doc/scipy/tutorial/integrate.html

int_scipy=sc.integrate.quad(funcion,a,b)
Error_scupy=-1-int_scipy[0]
print("Uso de SciPy:",int_scipy[0],"Error uso SciPy",Error_scupy)

"""EJERCICIO 2:
DERIVACIÓN NUMÉRICA
"""

#Este ejercicio busca que usted implemente correctamente dos métodos de derivación numérica forward difference y central difference.
#Pruebe distintos valores de h.
import numpy as np
import matplotlib.pylab as plt

# Función a derivar
def funcion(x1):
    	return np.cos(x1)
def dfuncion(x1):
    	return -np.sin(x1)

#El intervalo de integración es de 0 a 2pi.
#Divida el intervalo de integración en M secciones para calcular sus derivadas.
#pruebe distintos valores de M

# paso 1: use linespace (ver documentación: https://numpy.org/doc/stable/reference/generated/numpy.linspace.html)
# para hacer el arreglo de su intervalo en x
M=9999
a=0
b=2.0*np.pi
x=np.linspace(a,b,M)
h=(b-a)/(M-1)
#paso 2: genere el arreglo de valores de su función fx:
fx=funcion(x)

#1) grafique su función para verificar que hizo bien los pasos anteriores
plt.plot(x,fx)

# 2a). Implemente el algoritmo que le permita calcular la derivada de la función para los puntos en el intervalo 0 a 2pi usando forward difference.
df=(fx[1:]-fx[:-1])/h
#plt.plot(x[:-1],df,x[:-1],df1,x,dfuncion(x))

# 2b). Implemente el algoritmo que le permita calcular la derivada de la función para los puntos en el intervalo 0 a 2pi usando diferencia central.
df2=(fx[2:]-fx[:-2])/(2*h)
#plt.plot(x[1:-1],df2,x,dfuncion(x))

# 2c). Haga una gráfica de la función y sus derivadas obtenidas usando los dos métodos antes mencionados.
plt.plot(x[:-1],df,'r--',label='forward difference')
plt.plot(x[1:-1],df2,'b--',label="diferencia central")
plt.plot(x,dfuncion(x),'g--',label="derivada analitica")
plt.legend(loc='best')
plt.grid()

# 2d). Haga una grafica con dos subplots (uno por cada metodo) del error |(valor numérico - valor analitico) en el intervalo. (Si tienen problemas con los subplots pueden hacer dos gráficas)
plt.figure(figsize=(15,5))
plt.subplot(1,2,1)
plt.plot(x[:-1],df-dfuncion(x[:-1]))
plt.title('Error de forward difference')
plt.grid()
plt.subplot(1,2,2)
plt.plot(x[1:-1],df2-dfuncion(x[1:-1]))
plt.title('Error de diferencia central')
plt.grid()

# 2e). Implemente el algoritmo que le permita calcular la segunda derivada de la función en el intervalo 0 a 2pi. Haga una gráfica de la función y su segunda derivada.
ddf1=(fx[2:]+fx[:-2]-2*fx[1:-1])/(h**2)
plt.plot(x[1:-1],ddf1,'b--',label='segunda derivada numerica')
plt.plot(x,funcion(x),'r--',label='funcion')
plt.legend(loc='best')
plt.grid()

# 3) (opcional si terminan el ejercicio 2) Repita el ejercicio anterior usando algunos de los métodos de las librerías de scipy
# https://docs.scipy.org/doc/scipy/tutorial/integrate.html
d_sc=sc.misc.derivative(funcion,x,h)
plt.plot(x,d_sc)
plt.grid()
plt.show()

"""EJERCICIO 3: NEWTON-RAPHSON"""

# La idea de este ejercicio es que exploren la convergencia del método de Newton-Raphson para encontrar los ceros del siguiente polinomio:

def poli(x):
    	return (x**5)-(1.7*x**4)-(10.0*x**3)+(20.0*x*x)+ (9.0*x)-18.0

# Para esto:
# 1a.)  Haga una grafica del polinomio en el intervalo [-4:4].
x_NR=np.linspace(-4,4,100)
f_NR=poli(x_NR)
plt.figure(1)
plt.plot(x_NR,f_NR)
plt.title('figura 1')
plt.grid(True)

# 1b.) Usando su implementación de Newton-Raphson, imprima el valor de una raíz x0_r del polinomio encontrada si usa como x_guess inicial el valor -2.75.
#Imprima el valor de x0_r encontrado y de f(x0_r)
def NewtonRapson(x,Eror_esp):
	h_NR=Eror_esp/10
	y=poli(x)
	N=0
	while(np.abs(y)>Eror_esp):
		df=sc.misc.derivative(poli,x,h_NR)
		x=x-poli(x)/df
		y=poli(x)
		N+=1
	return [x,y,N]

print(NewtonRapson(-2.75,1e-5))

# 1c.) Repita lo anterior para 1000 valores de x_guess generados aleatoriamente en el intervalo [-4:4].
#Cuente cuantas iteraciones necesita su codigo para encontrar una raiz x_r del polinomio (tal que $f(x_r) sea menor a 10^{-10} para cada x_guess.
#Haga una grafica (use un scatter) del numero de iteraciones en funcion del x_guess inicial.
Error=1e-10
X_rand=np.random.random(1000)*8-4
SCATTER=np.array([])
RaizF=np.array([])
for i in X_rand:
  AUX=NewtonRapson(i,Error)
  SCATTER=np.append(SCATTER,AUX[2])
  RaizF=np.append(RaizF,AUX[1])

#Grafico
plt.plot(X_rand,SCATTER,'bo',markersize=1)
plt.title('figura 2')
plt.ylabel('Numero de iteraciones')
plt.xlabel('x guess')
plt.grid(True)

# 1c.) Haga una grafica (use un scatter) de la raíz encontrada (en el eje y) en función del x_guess inicial (en el eje x).
plt.plot(X_rand,RaizF,'bo',markersize=1)
plt.title('figura 3')
plt.ylabel('valor de y')
plt.xlabel('y estimado')
plt.grid(True)

# 1d.) Imprima un mensaje en donde explique por que cree que para ciertos valores de x_guess el numero de iteraciones necesarios para encontrar la raiz es mayor.
#Ademas haga un analisis y describa que pasa con los valores de x_r encontrados en esos puntos "problema" comprados con los encontrados para otros valores de x_guess.
DF=sc.misc.derivative(poli,X_rand,Error)
plt.plot(DF,SCATTER,'bo',markersize=1)
plt.title('figura 4')
plt.ylabel('nuemro de iteraciones')
plt.xlabel('Valor de la derivada de y(X)')
plt.grid(True)

print("Podemos observar, según la última figura (fig 4), que los puntos problemáticos")
print("en los cuales el algoritmo requiere más iteraciones para alcanzar la solución ")
print("se caracterizan por tener un valor inicial de la derivada cercano a cero. Esto ")
print("es algo que ya conocemos como un problema para el algoritmo. Sin embargo, también")
print(" notamos que los valores hacia la derecha de la gráfica (fig 2) presentan problemas ")
print("similares, pero con una mayor dispersión. Esto podría deberse a que, en su trayectoria, ")
print("se encuentran en el intervalo (1-2) (fig 1)donde los valores de la derivada son cercanos a cero.")